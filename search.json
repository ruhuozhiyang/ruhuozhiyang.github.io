[{"title":"HDFS 手册","date":"2023-05-20T13:27:02.401Z","url":"/2023/05/20/HDFS%E6%89%8B%E5%86%8C/","categories":[[" ",""]],"content":"1. 概念1.1. hdfs dfs 和 hadoop fs 区别? hadoop fs 用的面最广，可以操作任何文件系统，这里 fs 泛指文件系统。 hdfs dfs 特定用于 HDFS。 1.2. HDFS 和 MapReduceHadoop 的框架最核心的设计就是：HDFS 和 MapReduce。HDFS 为海量的数据提供了存储，而 MapReduce 为海量的数据提供了计算。HDFS 可以理解为一个分布式的、有冗余备份的、可以动态扩展的用来存储大规模数据的大硬盘；而 MapReduce 则理解为一个计算引擎，按照 MapReduce 的规则编写 Map &#x2F; Reduce 计算的程序，可以完成计算任务。HDFS 是一个分布式文件系统，引入存放文件元数据信息的服务器 Namenode 和实际存放数据的服务器 Datanode，对数据进行分布式储存和读取；而 MapReduce是一个计算框架，MapReduce 的核心思想是把计算任务分配给集群内的服务器里执行，先对计算任务进行拆分【Map 计算 &#x2F; Reduce 计算】，再借助任务调度器 JobTracker 对任务进行分布式计算。 1.3. 配额HDFS 允许管理员为每一个用户和每一个文件夹设置配额：命名配额和空间配额。name quota：该目录下的名字数量做硬性限制，为文件夹下的数量作出的限制,超过限制则会报错：quota exceed，最大值配额:Long.MAX_Valus。新创建的文件夹没有分配quota。space quota：设置一个文件夹的大小，如果超过则块写入会失败（副本也算）。最大的配额：Long.Max_Value。配额设置为0还是运行文件创建，但是不能向文件中写入块。文件夹不使用主机文件系统不计算在空间配额里面，主机文件系统用来记录文件源数据的数据不算在配额中。 1.4. 安全模式HDFS 的 block 丢失过多会进入安全模式。需要先退出安全模式，然后检测、修复或删除坏块。 2. 命令2.1. 将 HDFS 中文件下载到本地 2.2. 查看某个目录下的所有文件 2.3. 删除某个目录下所有文件 2.4. 创建某个文件夹 2.5. 创建某个文件 2.6. 上传某个文件 2.7. 查看文件夹的配额"},{"title":"Redis 内存数据库","date":"2023-05-20T13:24:20.764Z","url":"/2023/05/20/Redis%E6%89%8B%E5%86%8C/","categories":[[" ",""]],"content":"1. 相关概念1.1. 与 memcache 比较与缓存服务器 memcache 对比，redis 的一大优势就是支持数据的持久化，而 memcache 一旦重启，内存中保存的数据就完全消失了。 1.2. 支持的数据类型redis 不仅可以存储普通的字符串键，共支持五种数据类型： string（字符串） hash（哈希） list（列表） set（集合） zset(sorted set：有序集合) 1.3. 主从复制为了扩展Redis的读性能和为Redis提供故障转移支持，实现了主从复制特性：主服务器与从服务器。执行复制的从服务器会连接上主服务器，接受主服务器发送的整个数据库的初始副本，之后主服务器执行的写命令，都会发送给所有的从服务器去执行，从而实时的更新从服务器的数据集，从服务器包含的数据会不断地进行更新，所以客户端可以向任意一个从服务器发送读请求，以此来避免对主服务器进行集中式的访问。 1.4. 持久化拥有两种不同形式的持久化方法。快照RDB和只追加文件AOF。一种是时间点转储(point-in-time dump)，；一种是将所有修改了数据库的命令都写入一个只追加文件里面，用户可以根据数据的重要程度，将只追加写入 设置为从不同步&#x2F;每秒钟同步一次&#x2F;每写入一个命令就同步一次。AOF持久化会将被执行的写命令写到AOF文件的末尾，以此来记录数据发生的变化。因此，Redis只要从头到尾重新执行一次AOF文件包含的所有的写命令，就可以恢复AOF文件所记录的数据集。 1.5. 数据分片分片是一种将数据划分为多个部分的方法，对数据的划分可以基于键包含的ID、基于键的散列值，或者基于以上两者的某种组合。通过对数据进行分片，用户可以将数据存储到多台机器里面，也可以从多台机器上面获取数据，这种方法在解决某些问题的时候可以获得线性级别的性能提升。 1.6. 选用场景是否选择 redis 要根据具体的情况，如果程序对性能的要求不高，又或者因为费用原因而没有办法将大量的数据存储到内存里面，那么可能就不需要使用 redis。 1.7. redis 数据结构 SDSC字符串和 redis 的 SDS（simple dynamic string） 1.8. 多个数据库单机 redis 情况下： redis 是一个字典结构的存储服务器，而实际上一个 redis 实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中，这与我们熟知的在一个关系数据库实例中可以创建多个数据库类似，可以将其中的每个字典都理解成一个独立的数据库。 redis 数据库的数量是固定的，并在配置文件中设置，默认情况下，有16个数据库，且每个数据库都由一个数字（而不是名称）来标识。 redis 不支持自定义数据库的名字，每个数据库都以编号命名，开发者必须自己记录哪些数据库存储了哪些数据。 redis 也不支持为每个数据库设置不同的访问密码，所以一个客户端要么可以访问全部数据库，要么连一个数据库也没有权限访问。 redis 多个数据库之间并不是完全隔离的，比如 FLUSHALL 命令可以清空一个 redis 实例中所有数据库中的数据。综上，redis 的这些数据库更像是一种命名空间，而不适宜存储不同应用程序的数据。比如可以使用0号数据库存储某个应用生产环境中的数据，使用1号数据库存储测试环境中的数据，但不适宜使用0号数据库存储A应用的数据而使用1号数据库B应用的数据，不同的应用应该使用不同的 redis 实例存储数据。由于 redis 非常轻量级，一个空 redis 实例占用的内存只有 1M 左右，所以不用担心多个 redis 实例会额外占用很多内存。 redis 集群情况下： redis 支持多个数据库，并且每个数据库的数据是隔离的不能共享，但是基于单机才有，如果是集群就没有数据库的概念。 1.9.单线程redis 是单线程处理请求的。 2. 命令2.1. 查看有多少个DB 2.2. 切换DB 2.3. 清除某个库中的所有数据 2.4. 查看键 key_name 所占的存储空间 Redis缓存问题 Redis命令"},{"title":"ElasticSearch 手册","date":"2023-05-18T11:48:52.113Z","url":"/2023/05/18/ES%E6%89%8B%E5%86%8C/","categories":[[" ",""]],"content":"1. 概念Index-库、Type-表、Document-数据Hits数组默认返回10个。scroll 查询可以用来对 Elasticsearch 有效地执行大批量的文档查询，而又不用付出深度分页那种代价。 ES存储时间格式的形式有关，ES默认的存储时间格式是UTC时间，但是在我的ES中存储的timestamp是UTC+8时间，所以看到的时间是2019-05-09T18:25:01.082327+0800和2019-05-09T18:25:01.200825+0800。第一次查询时：{“range”: {“timestamp”: {“from”: “2019-05-09T18:25:01.000”}}}查询的是默认的UTC时间，即是2019-05-09T18:25:01.000+0000,转化为UTC+8是：2019-05-10T04:25:01.000+0800，所以查询不到任何数据第二次查询：{“range”: {“timestamp”: {“from”: “2019-05-09T18:25:01.000+0800”}}}查询的就是UTC+8时间，所以可查到数据。 1.1. Keyword 和 Text 的差别2. 命令2.1. 查看 ES 集群所有的索引 2.2. 查看ES集群的健康情况 2.3. 查看ES集群所有节点信息【信息比较全面】 2.4. 查看ES集群主节点 2.5. 查看某个索引的动态映射信息 例如执行 curl host_ip:9200&#x2F;bucket_002&#x2F;_mapping，结果如下： 2.6. 模糊查询 2.7. 返回符合条件的文档数 3. 相关链接《Elasticsearch 权威指南》中文版"},{"title":"JVM 调优手册","date":"2023-05-17T12:24:11.506Z","url":"/2023/05/17/JVM%E8%B0%83%E4%BC%98/","categories":[[" ",""]]},{"title":"HBase 性能调参","date":"2023-05-17T12:15:32.859Z","url":"/2023/05/17/HBase%E6%80%A7%E8%83%BD%E8%B0%83%E5%8F%82/","categories":[[" ",""]],"content":"hbase.hregion.memstore.block.multiplier 4&#x3D;&gt;5hbase.hregion.memstore.flush.size 134217728&#x3D;&gt;268435456hbase.hstore.compaction.max 10&#x3D;&gt;15 regionserver.handler.count 是指单个 regionserver 允许的 rpc 请求的线程数量，默认值是 30，生产环境建议使用 60，也不是越大越好，特别是当请求内容很大的时候，比如 scan&#x2F;put 几 M 的数据，会占用过多的内存，有可能导致频繁的 GC（垃圾回收），甚至出现内存溢出。 调整 RegionServer 的读和写缓冲区的大小，此处 0.4 为 40%，读写缓存的总和控制在 80% 以内，否则可能造成 Hbase 无法启动的情况。根据写需求，可加大 hbase.regionserver.global.memstore.size 的比例默认读写缓存比例值都为40%如果为了提高写速度，可以将读调整为 10%，写调整为 70%。 避免 regionserver 级别的刷写regionserver 运行在 JVM 之上，regionserver 占用的堆内存是向 JVM 堆内存申请的。 hbase_heapsize（region server heapsize）是 RegionServer 占用的 JVM 内存大小。 hbase.regionserver.global.memstore.size 是一个 regionserver 总的写缓存（即所有 memstore 之和）占用 hbase_heapsize 的比例。【默认值是 0.4】 当一个 regionserver 总的写缓存（即所有 memstore 之和）&gt; hbase_heapsize ✖️ hbase.regionserver.global.memstore.size，就会触发 regionserver 级别刷写，阻塞 regionserver 的所有写请求，且时间较长。 设置合理的 region 数量和 region 大小bulkload 和 put 加载数据？ Jetty IOException: Too many open files client-scan 过滤数据： 合理的region数量和region大小 "},{"title":"ZooKeeper 手册","date":"2023-05-16T05:21:19.335Z","url":"/2023/05/16/ZooKeeper%E6%89%8B%E5%86%8C/","categories":[[" ",""]],"content":"hbase:mate 表所在的RegionServer 信息被存储到了zookeeper 中的 &#x2F;hbase&#x2F;meta-region-server 节点"},{"title":"HBase 命令行手册","date":"2023-05-15T17:54:41.685Z","url":"/2023/05/16/HBase%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%8B%E5%86%8C/","categories":[[" ",""]],"content":"1. 登录 shell 2. 列出所有的表 3. 统计一个表中数据的行数 4. 清空｜删除表数据 5. 查看一张表的前 N 条记录 6. 查看一张表中指定 rowkey 的数据 7. Scan 扫描全表并指定返回特定的列 Scan 更多用法 8. 写入原生的数据类型 9. HBaseFsck（hbck）HBaseFsck（hbck）是一个用于检查区域一致性和表完整性问题并修复损坏的HBase的工具。 10. 重分配 region，解决 RIT 问题 11.查看表信息 12.RowCounter统计HBase表行数 13.检查表状态 14.查看分区信息 15.找出异常的 Region 16.确认一下表的信息和数据 17.更新 Region&#x2F;Table 信息 18.查看多个版本的数据get ‘tmp_mutilversion’,’rk1114’,{COLUMN &#x3D;&gt; ‘f:q1’, VERSIONS &#x3D;&gt; 2} hbase 删除会删掉hbase:meta中的信息吗?"},{"title":"Nodejs & Npm 的关系","date":"2023-05-15T17:47:09.363Z","url":"/2023/05/16/Nodejs%20&%20Npm%20%E7%9A%84%E5%85%B3%E7%B3%BB/","categories":[[" ",""]],"content":"1.问题我们知道，JavaScript 的出现可以说是 Java Applet 的掘墓人，它因为是浏览器原生支持的，无需像 Applet 那样还要额外安装 Applet 相关程序，一来很方便，二来执行效率也比后者要高很多，它也同样能满足请求后端服务、实现动态网页的需求。 可 JavaScript 不满足于只做一个前端页面和后端服务交互的脚本语言，我 JS 自己也想开发后端服务。在前端因为有浏览器原生支持所以 JS 才得以运行，但是在服务器端怎么执行 JS 的代码？就像 PHP 和 Python 脚本，能做为后端语言也是因为有解释器的支持。 2.方案既然浏览器能支持 JS 的执行，那我就利用一下浏览器内核引擎，再加点自己的东西，于是有了 Nodejs。 Nodejs 是对 Chrome V8 引擎的封装，从而可以支持 JavaScript 的运行，也就是说，Nodejs 与谷歌浏览器在解析JavaScript 时都使用了V8引擎。Nodejs 不是一个 JS 文件，而是一个 JS 的运行环境，是一个 JS 的开发平台。作为开发平台，它当然提供了诸多的 API 来满足不同的业务需求。Nodejs 使得 JavaScript 能够运行于服务端，并使其成为地位与服务端语言（Python、PHP 等）一样高的脚本语言。 Nodejs 的能力 提供了替代的API，使得 V8 引擎在非浏览器的环境下运行地更好； V8 引擎执行 JavaScript 的速度非常快，性能非常好； 是一个基于 Chrome JavaScript 运行时建立的平台，能方便地搭建响应速度快、易于扩展的网络应用。 现在 JS 的开发平台已经搭建起来了，可是在开发网站时往往依赖的库很多，例如依赖的 jquery、bootstrap 库等都需要自己去不同的地方单独下载，并导入工程。就很麻烦，而且不好管理版本，所以为什么不用管理工具来统一管理这些资源？ 于是 Npm 就来了，Npm 全称是 Node package manager（Node 包管理工具），和 Maven、Gradle 一样是个包管理工具，只不过 Maven 与 Gradle 是用来管理 Java jar包的，而 Npm 是用来管理 Node 包的。 Npm 的实现原理与 Maven&amp;Gradle 一样。 先建立一个远程代码仓库，用来存放所有的被共享的 Node 库，并且每个 Node 库都有自己唯一的标识符； 用户想要引入某个 Node 库时，只需引用对应的标识符，就会自动下载下来。 Npm 一开始出来的时候，并没有人在意它。后来 Nodejs 开发完成后，正缺少一个包管理工具，于是二者一拍即合。结果就是 Nodejs 内置了Npm，这也导致了要下载 Npm 的话，必须得下载 Nodejs。随着 Nodejs 流行，很多人开始使用Npm 下载和共享代码，Npm 已经成了前端的标配。 3.Npm常见操作3.1.Npm源"},{"title":"YCSB测试HBase读写性能","date":"2023-05-15T14:38:58.053Z","url":"/2023/05/15/YCSB%E6%B5%8B%E8%AF%95HBase%E8%AF%BB%E5%86%99%E6%80%A7%E8%83%BD/","categories":[[" ",""]],"content":"1.测试类型基准测试、压力测试 2.YCSB测试命令3.性能调优CPU、磁盘IO、网卡 "},{"title":"HBase 的 RIT 问题","date":"2023-05-14T15:07:42.146Z","url":"/2023/05/14/HBase%E7%9A%84RIT%E9%97%AE%E9%A2%98/","categories":[[" ",""]],"content":"背景：Region-In-Trasition机制：从字面意思来看，Region-In-Transition说的是Region变迁机制，实际上是指在一次特定操作行为中Region状态的变迁，例如merge、split、assign、unssign等操作。RIT问题指的是在RIT过程中出现异常情况，然后导致region的状态一直保持在RIT，使得HBase出现异常。 问题描述： 1.HBase2.0变化Region 的 RIT 状态不再由 ZooKeeper 参与，而是只由 HMaster 和 RegionServer 管理。 2.重置 Region 的状态修改表 hbase:meta 中 region 的状态信息为 offline。还需要清除 WAL 日志，并重启 HMaster。 问题：将某个表对应的分区的状态都修改为了 CLOSED，但是 drop 删除报错仍然报错需要先 disabled：于是先查看表 hbase:meta 中表的状态，发现为 disabling，于是需要修改表状态为 disabled。 3.HDFS坏块 Hbase永久RIT异常："},{"title":"Linux 手册","date":"2023-01-02T10:13:43.466Z","url":"/2023/01/02/Linux%20%E6%89%8B%E5%86%8C/","categories":[[" ",""]],"content":"1. 概念 Linux 一切皆文件。 符号｜在 Linux 中是管道的意思，前一步处理的结果传入下一步处理，所以不同的命令可以通过｜结合使用。 ～ 与 &#x2F;home，～ 是当前用户的家目录，&#x2F;home 是家目录。 常见的文件目录功能： &#x2F;dev，dev 是 device的英文缩写。&#x2F;dev 这个目录对所有的用户都十分重要，因为在这个目录中包含了所有Linux系统中使用的外部设备。但是这里并不是放的外部设备的驱动程序，这一点和 windows,dos 操作系统不一样。它实际上是一个访问这些外部设备的端口。我们可以非常方便地去访问这些外部设备，和访问一个文件，一个目录没有任何区别。设备文件一般存放在 &#x2F;dev 目录下，设备文件分为两种：块设备文件(b)和字符设备文件(c)。&#x2F;dev&#x2F;null，该设备是空设备，也称为位桶（bit bucket）或者黑洞(black hole)。你可以向它输入任何数据，但任何写入它的数据都会被抛弃。通常用于处理不需要的输出流。（当然，它也可以作为空的输入流）&#x2F;dev&#x2F;zero，该设备无穷尽地提供空字符（ASCII NUL, 0x00），可以使用任何你需要的数目。它通常用于向设备或文件写入字符串0，用于初始化数据存储。（当然，也可作为输出流的接受容器）。 &#x2F;etc 配置目录 &#x2F;usr 用户程序目录 &#x2F;tmp 临时目录 &#x2F;bin 用户二进制 &#x2F;sbin 系统二进制 &#x2F;usr&#x2F;bin 集中了几乎所有用户命令，是系统的软件库，另有些命令在 &#x2F;bin 或 &#x2F;usr&#x2F;local&#x2F;bin 中 主目录：&#x2F;root、&#x2F;home&#x2F;username 用户可执行文件：&#x2F;bin、&#x2F;usr&#x2F;bin、&#x2F;usr&#x2F;local&#x2F;bin 系统可执行文件：&#x2F;sbin、&#x2F;usr&#x2F;sbin、&#x2F;usr&#x2F;local&#x2F;sbin 其他挂载点：&#x2F;media、&#x2F;mnt 内核和Bootloader：&#x2F;boot 服务器数据：&#x2F;var、&#x2F;srv 系统信息：&#x2F;proc、&#x2F;sys 共享库：&#x2F;lib、&#x2F;usr&#x2F;lib、&#x2F;usr&#x2F;local&#x2F;lib 压缩文件 .tar｜.tar.gz｜.zip.tar 是格式压缩，.tar.gz 是进一步压缩的二次压缩。.tar.gz 压缩格式用于 Unix 操作系统，而 Zip 用于 Windows 操作系统。 tar：tar是*nix下的打包工具，生成的包通常也用tar作为扩展名，其实tar只是负责打包，不一定有压缩，事实上可以压缩，也可以不压缩，通常你看到xxxx.tar.gz，就表示这个tar包是压缩的，并且使用的压缩算法是GNU ZIP，而xxxx.tar.bz2就表示这个包使用了bzip2算法进行压缩，当然这样的命名只是一种惯例，并非强制。简单地说，tar就仅是打包。 jar：即Java Archive，Java的包，Java编译好之后生成class文件，但如果直接发布这些class文件的话会很不方便，所以就把许多的class文件打包成一个jar，jar中除了class文件还可以包括一些资源和配置文件，通常一个jar包就是一个java程序或者一个java库。 war：Web application Archive，与jar基本相同，但它通常表示这是一个Java的Web应用程序的包，tomcat这种Servlet容器会认出war包并自动部署。 tar是通用的另一种打包格式，为了部署到服务器时方便。而jar是java app server识别的java部署格式，其实是Zip文件，只是内部的文件有规范。war是专用于web app的jar。另外还有用于enterprise app的ear后缀。 scp 和 sftp 两者都是基于 ssh 安全协议的文件传输命令； scp 比较简单，是轻量级的，sftp 的功能则比较多； sftp 在文件传输过程中中断的话，连接后还可以继续传输，但 scp 不行； Linux 环境变量 按照生命周期来分，可以分为两类：永久的：需要用户修改相关的 profile 配置文件，source 重新加载，变量永久生效。临时的：用户利用 export 命令，在当前终端下声明环境变量，关闭 shell 终端失效。 按照作用域来分，也可以分为两类：系统环境变量：系统环境变量对该系统中所有用户都有效。用户环境变量：这种类型的环境变量只对特定的用户有效。 Unix &#x2F; Linux 中有两个 profile 文件 &#x2F;etc&#x2F;profile，是全局 profile 文件，设置后会影响到所有用户。 &#x2F;home&#x2F;username&#x2F;.profile 或 &#x2F;home&#x2F;username&#x2F;.bash_profile，是特定用户的环境变量。 补充：profile 文件是 Unix 上才有的；.bash_profile 文件是 Linux 下有的【Linux下，用户目录没有 .profile 文件】 epoll、kqueue机制 传给脚本的参数 $# 是传给脚本的参数个数 $0 是脚本本身的名字 $1 是传递给该shell脚本的第一个参数 $2 是传递给该shell脚本的第二个参数 $@ 是传给脚本的所有参数的列表 profile 文件的执行顺序 bash 登录的时候，先执行全局的 profile 文件：&#x2F;etc&#x2F;profile 接着 bash 会检查当前用户的 home 目录中，是否有 .bash_profile 或 .bash_login 或 .profile 文件，若有，则会执行其中一个，执行顺序为：.bash_profile -&gt; .bash_login -&gt; .profile。 etc&#x2F;hosts 文件在 etc&#x2F;hosts 文件中手动配置域名和 IP 的映射，这样就可以不用 DNS 就可以解析域名了。留有疑问，我本地自定义了一个域名，并在hosts文件中配置了映射为百度的IP地址，但是就是访问不了？ Linux下安装软件的方式 工具安装。软件包管理工具有：apt、rpm、yum 等。 apt，即 advanced package tools。apt 是现今最成熟的软件包管理系统，它可以自动检测软件依赖问题，下载和安装所有文件。甚至只需要一条命令，就可以更新整个系统上所有的软件包。apt 工具最初被设计运行于 Debian 系统上，只支持 .deb 格式的软件包文件。如今 apt 工具已经被移植到使用 rpm 软件包机制的发行版 Linux 系统上，可以从 apt-rpm.org 获得 apt 的 rpm 版本。apt 工具最常用的有两个命令：apt-get：用于执行和软件包安装有关的所有操作。apt-cache：用于查找软件包的相关信息。apt 工具是 Ubuntu、Debian 下软件包管理工具。 rpm，即 redhat package manager，原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他 Linux 发行版的采用。 rpm 套件管理方式的出现，让 Linux 易于安装、升级，间接提升了 Linux 的适用度。rpm 此名词既可以指 .rpm 文件格式的软件包，也可以指其本身的软件包管理器。rpm 工具最早由 Red Hat 研制，现在也由开源社区开发。rpm 工具通常随附于 Linux 发行版，但也有单独将 rpm 作为应用软件发行。 rpm 包的安装有一个很大的缺点：文件的关联性太大，有时候装一个软件要安装很多其他的软件包，管理软件间关联关系很麻烦。为此 RedHat 开发了 yum 安装方法，yum 并不是一种包，而是安装包的软件。yum 可以彻底解决这个关联性的问题，很方便，只要配置两个文件即可安装，安装方法是： 简单点说，rpm 只能安装已经下载到本地机器上的 rpm 包。yum 能从指定服务器在线下载并安装 rpm 包，还能更新系统，且还能自动处理包与包之间的依赖问题，这个是 rpm 工具所不具备的。 rpm &amp; tarrpm 一般都是预先编译好的文件，它可能已经绑定到某种 CPU 或者 Linux 发行版上面了。tar 一般包括编译脚本，你可以在你的环境下编译，所以具有通用性；tar 只是一种压缩文件格式，一般都是软件的源码打包成的，需要自己解包，然后进行安装三部曲 ./configure, make, make install 来安装软件。如果你的包不想开放源代码，你可以制作成 rpm，如果开源，用 tar 更方便。 yum 工具是 CentOS、Redhat 下的软件包管理工具。 源代码安装。源代码压缩文件包的格式后缀可以是：.tar、tar.gz、tar.bz2、tar.Z。解压好源代码压缩文件后，一般依次执行如下的命令： 二进制文件安装。二进制文件是机器能直接执行的文件，二进制包的安装比较简单，我们需要做的只是将从网络上下载的二进制包解压后放到合适的目录，然后将包含可执行的主程序文件的目录添加进PATH环境变量即可。 文件属性Linux系统中，文件属性“l”是链接文件，相当于windows的快捷方式; “b”是块设备,硬盘就是一个例子; “c”是字符设备文件,鼠标,键盘算是; “d”是目录文件,相当于windows的文件夹； 硬连接和软连接Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln 命令产生硬链接。硬连接硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。软连接另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。 删除符号连接f3，对f1、f2无影响； 删除硬连接f2，对f1、f3也无影响； 删除原文件f1，对硬连接f2没有影响，而符号连接f3失效； 同时删除原文件f1，硬连接f2，整个文件会真正的被删除。 firewall 和阿里云 ECS 的安全组的关系？阿里云的安全组是一种虚拟防火墙，具有状态检测和数据包过滤的功能。控制台安全组放行某个端口，只能说明安全组没有限制这个端口的访问，不能说明这个端口已经开启。如需外网访问 ECS 服务器的端口需要满足以下三个必要条件： 安全组规则放行该端口； 对应端口的程序软件是启动运行状态，并且监听地址为 0.0.0.0（您可通过执行 netstat -ano | grep 端口号命令来检测端口是否处于监听状态）； 已关闭 ECS 实例内部防火墙firewall，或者防火墙firewall已放行该端口； 内核 &amp; Shell &amp; 终端模拟器管理计算机硬件的其实是内核，而用户通过 Shell 来与计算机的内核通信。Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。Shell 本质上就是能执行各种命令的宏处理器，而 bash(&#x2F;bin&#x2F;bash) 是 Linux 系统默认的 shell。如果是不带有图形环境的 Linux 系统（比如专用于服务器的系统），启动后就直接是命令行环境。不过，现在大部分的 Linux 发行版，尤其是针对普通用户的发行版，都是图形环境。用户登录系统后，自动进入图形环境，需要自己启动终端模拟器，才能进入命令行环境。所谓“终端模拟器”（terminal emulator）就是一个模拟命令行窗口的程序，让用户在一个窗口中使用命令行环境，并且提供各种附加功能，比如调整颜色、字体大小、行距等等。不同 Linux 发行版（准确地说是不同的桌面环境）带有的终端程序是不一样的，比如 KDE 桌面环境的终端程序是 konsole，Gnome 桌面环境的终端程序是 gnome-terminal，用户也可以安装第三方的终端程序。所有终端程序，尽管名字不同，基本功能都是一样的，就是让用户可以进入命令行环境，使用 Shell。 更多 bash 用法见文档链接 CPU cpi全称为 clock cycle per instruction，即每条计算机指令执行所需的 cpu 时钟周期。 cpu 时钟周期是一个时钟脉冲所需要的时间，也叫节拍脉冲或 T 周期，它是 cpu 中最小的时间单位。 脉冲通常是指电子技术中经常运用的一种像脉搏似的短暂起伏的电冲击(电压或电流)。 主要特性有波形、幅度、宽度和重复频率。 脉冲是相对于连续信号在整个信号周期内短时间发生的信号，大部分信号周期内没有信号。 就像人的脉搏一样。 cpu 时钟频率也叫主频，是 1 秒钟内的时钟脉冲个数，即 cpu 时钟周期的倒数。 cpu 执行时间运行一个程序所需要的 cpu 执行时间 &#x3D; 总时钟周期数 &#x2F; 主频 &#x3D; 总指令条数 * cpi &#x2F; 主频。 相关概念——物理 cpu 数（Socket）、核心core、thread（1）物理 cpu 数主板上实际插入的 cpu 硬件个数（socket），由于在主板上引入多个 cpu 插槽需要更复杂的硬件支持（连接不同插槽的 cpu 到内存和其他资源），通常只会在服务器上才这样做，在家用电脑中，一般主板上只会有一个 cpu 插槽。（2）核心 core起初，每个物理 cpu 上只有一个核心 core，对操作系统而言，也就是同一时刻只能运行一个进程&#x2F;线程。 为了提高性能，cpu 厂商开始在单个物理 cpu 上增加核心（实实在在的硬件存在），也就出现了双核心 cpu 以及多核心 cpu。双核心 cpu 也就是同一时刻能够运行两个进程&#x2F;线程的 cpu。（3）同时多线程技术（simultaneous multithreading）和 超线程技术（hyper–threading&#x2F;HT）本质同样是为了提高单个 core 同一时刻能够执行的多线程数的技术，充分利用单个 core 的计算能力，尽量让其”一刻也不得闲”。simultaneous multithreading 缩写是 SMT，是 AMD 和其他 cpu 厂商的称呼。 hyper–threading 是 Intel 的称呼，也可以认为 hyper–threading 是 SMT 的一种具体技术实现。 Linux下查看 cpu 的信息 centos 系统下删除 mysql 及 mysqld。先利用 rpm 找出所有的 sql 相关的文件：Rpm -q -a | grep sql然后利用rpm删除找到的文件：Rpm -e … Poller 的 fd 集合 部分编译器下，比如gcc， 两个long合用,即long long类型，表示C语言目前最长的系统整型类型，每个long long类型占8字节，64位。其格式化字符为”%lld”。 Source 设置环境变量只在当前 shell 窗口下生效，重新打开一个窗口要重新 source setenv.sh 而且要注意直接 .&#x2F; 执行和 source 执行的差别。 UINT64_MAX 再增加的溢出问题；例如 UINT64_MAX + 常数，就会产生溢出问题，得到意想不到的结果或直接报错。 常用的环境变量如下： PATH 决定了 shell 将到哪些目录中寻找命令或程序 HOME 当前用户主目录 HISTSIZE 历史记录数 LOGNAME 当前用户的登录名 HOSTNAME 指主机的名称 SHELL 当前用户Shell类型 LANGUGE 语言相关的环境变量，多语言可以修改此环境变量 MAIL 当前用户的邮件存放目录 PS1 基本提示符，对于root用户是＃，对于普通用户是＄ SSHSSH 只是一种协议，存在多种实现，既有商业实现，也有开源实现。本人用的是开源自由实现 OpenSSH。 SSH 密码登录 &amp; 公钥登录。加上 -v -l pi 可以将连接时候的日志都打印出来。见公钥登录 SSH 远程连接时，报错”ssh_exchange_identification: Connection closed by remote host”，可能原因如下。（1）远程主机启用了 DenyHosts 服务。如果远程主机安装了 DenyHosts 服务，需要查看远程主机 &#x2F;etc&#x2F;hosts.deny 文件是否有本机的记录，如有则将记录删除，并执行如下命令重启 sshd 和 rsyslog 服务。 （2）客户端连接数过多。缺省情况下，SSH终端连接个数最大为 10，这种情况下，需要修改 SSH 的配置文件并重启 SSHD。 mac 添加 ssh config 配置，快速登录 linux 系统。（1）访问根目录下 .ssh 文件夹并通过如下命令生成本机的 id_rsa（私钥）与 id_rsa.pub（公钥）文件。 （2）创建并编辑配置文件 config。 （3）在远程主机的目标用户根目录下的 .ssh 文件目录下创建文件 authorized_keys，已有则忽略；并追加本机公钥内容。 stdin &amp; stdoutLinux下，当一个用户进程被创建的时候，系统会自动为该进程创建三个数据流，分别为 stdin、stdout、stderr。 符号 &gt; 可以将程序的标准输出 stdout 重定向到文件中。 符号 &lt; 将程序的标准输入重定向为从文件输入。 执行当前工作目录中的 program 时还是老老实实的 .&#x2F;program 这样执行当前工作目录 .&#x2F; 一般并未在搜索范围之列，也就是 PATH 环境变量的值中并不包含 .&#x2F; 这个当前工作目录。为什么一般不能加入这个当前工作目录呢？主要原因在于安全问题。试想，一个evil 用户在自己的家目录 &#x2F;home&#x2F;evil&#x2F; 中放了一个名字叫ls的程序，当root用户或其它用户来到这个&#x2F;home&#x2F;evil&#x2F;目录时，想查看这个目录中有些啥子文件，于是执行ls命令，这时如果.&#x2F;目录在PATH环境变量中且搜索时先搜索这个.&#x2F;目录的话，则执行到的程序是&#x2F;home&#x2F;evil&#x2F;ls而不是&#x2F;bin&#x2F;ls程序，这样就会造成极大地安全问题。 Linux 上进程有 5 种状态：运行（正在运行或在运行队列中等待）中断（休眠中，受阻，在等待某个条件的形成或接受到信号）不可中断（收到信号不唤醒和不可运行，进程必须等待直到有中断发生）僵死（进程已终止, 但进程描述符存在, 直到父进程调用 wait4() 系统调用后释放）停止（进程收到 SIGSTOP、SIGSTP、SIGTIN、SIGTOU 信号后停止运行） BSD 格式和 SystemV 格式 2. 命令2.1. 阅览｜筛选文件内容 2.2. 查看当前的操作系统信息【CentOS】 2.3. 输出某个目录下所有内容 2.4. 控制用户对文件的权限chmod 全称是 change mode，该命令是控制用户对文件的权限的命令，Linux&#x2F;Unix 的文件调用权限分为三级: 文件所有者（Owner）、用户组（Group）、其它用户（Other Users），只有文件所有者和超级用户可以修改文件或目录的权限，可以使用如下两种模式指定文件的权限。 符号模式 绝对模式（八进制数字模式） 2.5. 定时任务 例如可以使用 crontab 定时执行某 shell 脚本，但是可能会出现 shell 脚本无法执行问题，具体情况如下。如果我们使用 crontab 来定时执行脚本，无法执行，但是直接通过命令（如：.／test.sh）又可以正常执行，这主要是因为无法读取环境变量。解决方法： 所有命令需要写成绝对路径形式，如：&#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker。 在 shell 脚本开头使用以下代码： 在 &#x2F;etc&#x2F;crontab 中添加环境变量，在可执行命令之前添加命令 . /etc/profile;/bin/sh，使得环境变量生效。 2.6. 查看机器的硬件情况 2.7. 删除文件｜文件夹 2.8. 用户操作 2.9. 压缩｜显示内容｜解压 tar &amp; tar.gz 文件 2.10. 查找文件｜文件夹 2.11. 显示目前资源限制的设定 2.12.2.13. 复制文件和目录 2.14. 显示电脑以及操作系统信息 2.15. 端口 2.16. 显示系统中已存在的环境变量 2.17. 文件追加内容 2.18. 建立软链接 2.19. 查看软件的安装路径 2.20. sudo 权限管理 2.21. su 切换用户 2.22. psLinux 中的 ps 命令是 Process Status 的缩写。ps 命令用来列出系统中当前运行的进程，提供进程信息的一次性查看。ps 命令列出的是当前那些进程的快照，就是执行 ps 命令的那个时刻的进程，如果想要动态的显示进程信息，就可以使用 top 命令。 ps 工具标识进程的5种状态码: D 不可中断 uninterruptible sleep (usually IO) R 运行 runnable (on run queue) S 中断 sleeping T 停止 traced or stopped Z 僵死 a defunct (“zombie”) process ps 命令参数 aux 和 -efps aux 可以列出所有的正在运行的进程，最近发现还是有些缺陷，用 ps aux 和 ps -ef 得到的结果居然不一样，以后尽量用 -ef 参数吧。例如，用/bmrt/blaph/blaph/bmgctl来启动进程，由于 ps aux 是用 BSD 格式来显示结果，所以 ps aux | grep bmgctl 可能只会显示到 /bmrt/blaph/blaph，后面的会被截掉。这样，如果用 ps aux | grep bmgctl 来过滤该进程，可能就会误伤，获取不到 bmgctl 进程。而 ps -ef 是用全格式的 System V 格式来显示结果的，显示的就是带全路径的进程名，会显示出 bmgctl，使用 ps -ef | grep bmgctl 命令就可以完整显示该进程了。 2.23. jps很多人都用过 Unix 系统里的 ps 命令，ps 命令主要是用来显示当前系统的进程情况，例如有哪些进程以及进程 pid。jps，全称 Java Virtual Machine Process Status Tool，即 Java 虚拟机进程状态工具。jps 是 jdk 提供的一个查看当前 java 进程的小工具，能够显示当前所有 java 进程的 pid，适合在 linux&#x2F;unix 平台上简单查看当前 java 进程的一些简单情况。我们可以通过 jps 命令来查看我们到底启动了多少个 java 进程（因为每一个 java 程序都会独占一个 JVM 实例）。 2.24. firewall 2.25. 查询 DNS 的记录 2.26. tmux 工具tmux 是一个终端复用器（terminal multiplexer），属于常用的开发工具。命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。用户与计算机的这种临时的交互，称为一次”会话”（session） 。会话的一个重要特点是，窗口与其中启动的进程是连在一起的：打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令，如果网络突然断线，再次登录是找不回上一次执行的命令的，因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。为了解决这个问题，会话与窗口可以【解绑】：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话【绑定】其他窗口。Tmux 就是会话与窗口的【解绑】工具，将它们彻底分离。 它允许在单个窗口中，同时访问多个会话，这对于同时运行多个命令行程序很有用。 它可以让新窗口”接入”已经存在的会话。 它允许每个会话有多个连接窗口，因此可以多人实时共享会话。 它还支持窗口任意的垂直和水平拆分。类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。以下是命令行交互命令： 键盘快捷键 更多用法见Tmux教程 2.27. kill 2.28. mv 移动包 2.29. nohup 2.30. 管道输出 –stdin这个选项用于从标准输入管道读入新的密码。 2.31. seq命令seq 是 sequence 的缩写，主要用来产生整数序列。 2.32. xargs命令xargs(extended arguments)，是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。之所以能用到这个命令，关键是由于很多命令不支持 | 管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令，例如： xargs 一般是和管道 | 一起使用。 参数含义： -i 或者是-I，这得看linux支持了，将 xargs 的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。 -L num，从标准输入一次读取 num 行送给 command 命令。 -l 同 -L。 2.33. dd命令Linux dd 命令用于读取、转换并输出数据。dd 可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。 参数含义： if&#x3D;文件名：输入文件名，默认为标准输入，即指定源文件。 of&#x3D;文件名：输出文件名，默认为标准输出，即指定目的文件。 ibs&#x3D;bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。 obs&#x3D;bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。 bs&#x3D;bytes：同时设置读入&#x2F;输出的块大小为bytes个字节。 count&#x3D;blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。 2.34. wc命令wc 命令用于计算字数，利用 wc 指令我们可以计算文件的 Byte 数、字数、或是行数。若不指定文件名称，或是所给予的文件名为”-“，则 wc 指令会从标准输入设备读取数据。 参数含义： -c 或 –bytes 或 –chars 只显示 Bytes 数。 -l 或 –lines 显示行数。 -w 或 –words 只显示字数。 2.35. 网口Linux ip 命令与 ifconfig 命令类似，但比 ifconfig 命令更加强大，主要功能是用于显示或设置网络设备。ip 命令是 Linux 加强版的的网络配置工具，用于代替 ifconfig 命令。 2.36. 命令行快捷键 光口和电口 10GE&#x2F;s带宽 交换空间Swap 在 Linux 上如何清除内存的 Cache、Buffer 和交换空间 内核是如何管理内存的？"}]